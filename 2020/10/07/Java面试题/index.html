<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="Java面试1.请说明Query接口的list方法和iterate方法有什么区别？考察点：接口 参考回答： ① list()方法无法利用一级缓存和二级缓存（对缓存只写不读），它只能在开启查询缓存的前提下使用查询缓存；iterate()方法可以充分利用缓存，如果目标数据只读或者读取频繁，使用iterate()方法可以减少性能开销。② list()方法不会引起N+1查询问题，而iterate()方法可">
<meta property="og:type" content="article">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/2020/10/07/Java%E9%9D%A2%E8%AF%95%E9%A2%98/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="Java面试1.请说明Query接口的list方法和iterate方法有什么区别？考察点：接口 参考回答： ① list()方法无法利用一级缓存和二级缓存（对缓存只写不读），它只能在开启查询缓存的前提下使用查询缓存；iterate()方法可以充分利用缓存，如果目标数据只读或者读取频繁，使用iterate()方法可以减少性能开销。② list()方法不会引起N+1查询问题，而iterate()方法可">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2020-10-07T03:48:01.173Z">
<meta property="article:modified_time" content="2020-09-09T13:49:45.381Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 5.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-Java面试题" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/10/07/Java%E9%9D%A2%E8%AF%95%E9%A2%98/" class="article-date">
  <time datetime="2020-10-07T03:48:01.173Z" itemprop="datePublished">2020-10-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Java面试"><a href="#Java面试" class="headerlink" title="Java面试"></a>Java面试</h1><h2 id="1-请说明Query接口的list方法和iterate方法有什么区别？"><a href="#1-请说明Query接口的list方法和iterate方法有什么区别？" class="headerlink" title="1.请说明Query接口的list方法和iterate方法有什么区别？"></a>1.请说明Query接口的list方法和iterate方法有什么区别？</h2><p>考察点：接口</p>
<h4 id="参考回答："><a href="#参考回答：" class="headerlink" title="参考回答："></a>参考回答：</h4><blockquote>
<p>① list()方法无法利用一级缓存和二级缓存（对缓存只写不读），它只能在开启查询缓存的前提下使用查询缓存；iterate()方法可以充分利用缓存，如果目标数据只读或者读取频繁，使用iterate()方法可以减少性能开销。<br>② list()方法不会引起N+1查询问题，而iterate()方法可能引起N+1查询问题</p>
</blockquote>
<h2 id="2-请你谈一下面向对象的”六原则一法则”。"><a href="#2-请你谈一下面向对象的”六原则一法则”。" class="headerlink" title="2. 请你谈一下面向对象的”六原则一法则”。"></a>2. 请你谈一下面向对象的”六原则一法则”。</h2><p>考察点：Java对象</p>
<h4 id="参考回答：-1"><a href="#参考回答：-1" class="headerlink" title="参考回答："></a>参考回答：</h4><blockquote>
<ol>
<li><code>单一职责原则</code>：==一个类只做它该做的事情。==（单一职责原则想表达的就是”高内聚”，写代码最终极的原则只有六个字”高内聚、低耦合”，所谓的高内聚就是一个代码模块只完成一项功能，在面向对象中，如果只让一个类完成它该做的事，而不涉及与它无关的领域就是践行了高内聚的原则，这个类就只有单一职责。另一个是模块化，好的自行车是组装车，从减震叉、刹车到变速器，所有的部件都是可以拆卸和重新组装的，好的乒乓球拍也不是成品拍，一定是底板和胶皮可以拆分和自行组装的，一个好的软件系统，它里面的每个功能模块也应该是可以轻易的拿到其他系统中使用的，这样才能实现软件复用的目标。）</li>
<li><code>开闭原则</code>：==软件实体应当对扩展开放，对修改关闭。==（在理想的状态下，当我们需要为一个软件系统增加新功能时，只需要从原来的系统派生出一些新类就可以，不需要修改原来的任何一行代码。要做到开闭有两个要点：①<code>抽象是关键</code>，一个系统中如果没有抽象类或接口系统就没有扩展点；②<code>封装可变性</code>，将系统中的各种可变因素封装到一个继承结构中，如果多个可变因素混杂在一起，系统将变得复杂而换乱，如果不清楚如何封装可变性，可以参考《设计模式精解》一书中对桥梁模式的讲解的章节。）</li>
<li><code>依赖倒转原则</code>：==面向接口编程。==（该原则说得直白和具体一些就是声明方法的参数类型、方法的返回类型、变量的引用类型时，尽可能使用抽象类型而不用具体类型，因为抽象类型可以被它的任何一个子类型所替代，请参考下面的里氏替换原则。）</li>
<li><code>里氏替换原则</code>：==任何时候都可以用子类型替换掉父类型。==（关于里氏替换原则的描述，Barbara Liskov女士的描述比这个要复杂得多，但简单的说就是能用父类型的地方就一定能使用子类型。里氏替换原则可以检查继承关系是否合理，如果一个继承关系违背了里氏替换原则，那么这个继承关系一定是错误的，需要对代码进行重构。例如让猫继承狗，或者狗继承猫，又或者让正方形继承长方形都是错误的继承关系，因为你很容易找到违反里氏替换原则的场景。需要注意的是：==子类一定是增加父类的能力而不是减少父类的能力，因为子类比父类的能力更多，把能力多的对象当成能力少的对象来用当然没有任何问题。==）</li>
<li><code>接口隔离原则</code>：接口要小而专，绝不能大而全。（臃肿的接口是对接口的污染，既然接口表示能力，那么一个接口只应该描述一种能力，接口也应该是高度内聚的。例如，琴棋书画就应该分别设计为四个接口，而不应设计成一个接口中的四个方法，因为如果设计成一个接口中的四个方法，那么这个接口很难用，毕竟琴棋书画四样都精通的人还是少数，而如果设计成四个接口，会几项就实现几个接口，这样的话每个接口被复用的可能性是很高的。Java中的接口代表能力、代表约定、代表角色，能否正确的使用接口一定是编程水平高低的重要标识。）</li>
<li><code>合成聚合复用原则</code>：==优先使用聚合或合成关系复用代码。==（通过继承来复用代码是面向对象程序设计中被滥用得最多的东西，因为所有的教科书都无一例外的对继承进行了鼓吹从而误导了初学者，类与类之间简单的说有三种关系，Is-A关系、Has-A关系、Use-A关系，分别代表继承、关联和依赖。其中，关联关系根据其关联的强度又可以进一步划分为关联、聚合和合成，但说白了都是Has-A关系，合成聚合复用原则想表达的是优先考虑Has-A关系而不是Is-A关系复用代码，原因嘛可以自己从百度上找到一万个理由，需要说明的是，即使在Java的API中也有不少滥用继承的例子，例如Properties类继承了Hashtable类，Stack类继承了Vector类，这些继承明显就是错误的，更好的做法是在Properties类中放置一个Hashtable类型的成员并且将其键和值都设置为字符串来存储数据，而Stack类的设计也应该是在Stack类中放一个Vector对象来存储数据。记住：==任何时候都不要继承工具类，工具是可以拥有并可以使用的，而不是拿来继承的。==）</li>
<li><code>迪米特法则</code>：==迪米特法则又叫最少知识原则，一个对象应当对其他对象有尽可能少的了解。==再复杂的系统都可以为用户提供一个简单的门面，Java Web开发中作为前端控制器的Servlet或Filter不就是一个门面吗，浏览器对服务器的运作方式一无所知，但是通过前端控制器就能够根据你的请求得到相应的服务。调停者模式也可以举一个简单的例子来说明，例如一台计算机，CPU、内存、硬盘、显卡、声卡各种设备需要相互配合才能很好的工作，但是如果这些东西都直接连接到一起，计算机的布线将异常复杂，在这种情况下，主板作为一个调停者的身份出现，它将各个设备连接在一起而不需要每个设备之间直接交换数据，这样就减小了系统的耦合度和复杂度。</li>
</ol>
</blockquote>
<h2 id="3-请说明如何通过反射获取和设置对象私有字段的值？"><a href="#3-请说明如何通过反射获取和设置对象私有字段的值？" class="headerlink" title="3.请说明如何通过反射获取和设置对象私有字段的值？"></a>3.请说明如何通过反射获取和设置对象私有字段的值？</h2><p>考察点：类</p>
<h3 id="参考回答：-2"><a href="#参考回答：-2" class="headerlink" title="#参考回答："></a>#参考回答：</h3><blockquote>
<p> 可以通过类对象的getDeclaredField()方法字段（Field）对象，然后再通过字段对象的setAccessible(true)将其设置为可以访问，接下来就可以通过get/set方法来获取/设置字段的值了。下面的代码实现了一个反射的工具类，其中的两个静态方法分别用于获取和设置私有字段的值，字段可以是基本类型也可以是对象类型且支持多级对象操作，例如ReflectionUtil.get(dog, “owner.car.engine.id”);可以获得dog对象的主人的汽车的引擎的ID号。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MethodInvokeTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        String str = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    Method m = str.getClass().getMethod(<span class="string">&quot;toUpperCase&quot;</span>);</span><br><span class="line">        System.out.println(m.invoke(str));  <span class="comment">// HELLO</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="4-请说明内部类可以引用他包含类的成员吗，如果可以，有没有什么限制吗？"><a href="#4-请说明内部类可以引用他包含类的成员吗，如果可以，有没有什么限制吗？" class="headerlink" title="4.请说明内部类可以引用他包含类的成员吗，如果可以，有没有什么限制吗？"></a>4.请说明内部类可以引用他包含类的成员吗，如果可以，有没有什么限制吗？</h2><p>考察点：类</p>
<h4 id="参考回答：-3"><a href="#参考回答：-3" class="headerlink" title="参考回答："></a>参考回答：</h4><blockquote>
<ol>
<li>一个内部类对象可以访问创建它的外部类对象的内容，</li>
<li>内部类如果不是static的，那么它可以访问创建它的外部类对象的所有属性</li>
<li>内部类如果是sattic的，即为nested class，那么它只可以访问创建它的外部类对象的所有static属性</li>
<li>一般普通类只有public或package的访问修饰，而内部类可以实现static，protected，private等访问修饰。</li>
<li>当从外部类继承的时候，内部类是不会被覆盖的，它们是完全独立的实体，每个都在自己的命名空间内，如果从内部类中明确地继承，就可以覆盖原来内部类的方法</li>
</ol>
</blockquote>
<h2 id="5-请说明JAVA语言如何进行异常处理，关键字：throws-throw-try-catch-finally分别代表什么意义？在try块中可以抛出异常吗？"><a href="#5-请说明JAVA语言如何进行异常处理，关键字：throws-throw-try-catch-finally分别代表什么意义？在try块中可以抛出异常吗？" class="headerlink" title="5.请说明JAVA语言如何进行异常处理，关键字：throws,throw,try,catch,finally分别代表什么意义？在try块中可以抛出异常吗？"></a>5.请说明JAVA语言如何进行异常处理，关键字：throws,throw,try,catch,finally分别代表什么意义？在try块中可以抛出异常吗？</h2><p>考察点：异常</p>
<h3 id="参考回答：-4"><a href="#参考回答：-4" class="headerlink" title="#参考回答："></a>#参考回答：</h3><ol>
<li>==Java 通过面向对象的方法进行异常处理，把各种不同的异常进行分类，并提供了良好的接口。==</li>
<li>==在Java中，每个异常都是一个对象，它是Throwable类或其它子类的实例。==</li>
<li>==当一个方法出现异常后便抛出一个异常对象，该对象中包含有异常信息，调用这个对象的方法可以捕获到这个异常并进行处理。==</li>
</ol>
<p>Java的异常处理是通过5个关键词来实现的：try、catch、throw、throws和finally。一般情况下是用try来执行一段程序，如果出现异常，系统会抛出（throws）一个异常，这时候你可以通过它的类型来捕捉（catch）它，或最后（finally）由缺省处理器来处理。用try来指定一块预防所有”异常”的程序。紧跟在try程序后面，应包含一个catch子句来指定你想要捕捉的”异常”的类型。throw语句用来明确地抛出一个”异常”。throws用来标明一个成员函数可能抛出的各种”异常”。Finally为确保一段代码不管发生什么”异常”都被执行一段代码。可以在一个成员函数调用的外面写一个try语句，在这个成员函数内部写另一个try语句保护其他代码。每当遇到一个try语句，”异常“的框架就放到堆栈上面，直到所有的try语句都完成。如果下一级的try语句没有对某种”异常”进行处理，堆栈就会展开，直到遇到有处理这种”异常”的try语句。</p>
<h2 id="5-请解释为什么集合类没有实现Cloneable和Serializable接口？"><a href="#5-请解释为什么集合类没有实现Cloneable和Serializable接口？" class="headerlink" title="5.请解释为什么集合类没有实现Cloneable和Serializable接口？"></a>5.请解释为什么集合类没有实现Cloneable和Serializable接口？</h2><p>考察点：JAVA集合</p>
<h4 id="参考回答：-5"><a href="#参考回答：-5" class="headerlink" title="参考回答："></a>参考回答：</h4><p>克隆(cloning)或者是序列化(serialization)的语义和含义是跟具体的实现相关的。因此，应该由集合类的具体实现来决定如何被克隆或者是序列化。<br>实现Serializable序列化的作用：将对象的状态保存在存储媒体中以便可以在以后重写创建出完全相同的副本；按值将对象从一个从一个应用程序域发向另一个应用程序域。<br>实现 Serializable接口的作用就是可以把对象存到字节流，然后可以恢复。所以你想如果你的对象没有序列化，怎么才能进行网络传输呢？要网络传输就得转为字节流，所以在分布式应用中，你就得实现序列化。如果你不需要分布式应用，那就没必要实现实现序列化。</p>
<h2 id="5-请你说明一下TreeMap的底层实现？"><a href="#5-请你说明一下TreeMap的底层实现？" class="headerlink" title="5.请你说明一下TreeMap的底层实现？"></a>5.请你说明一下TreeMap的底层实现？</h2><p>考点：集合</p>
<h4 id="参考回答：-6"><a href="#参考回答：-6" class="headerlink" title="参考回答："></a>参考回答：</h4><p>TreeMap 的实现就是红黑树数据结构，也就说是一棵自平衡的排序二叉树，这样就可以保证当需要快速检索指定节点。</p>
<p>红黑树的插入、删除、遍历时间复杂度都为O(lgN)，所以性能上低于哈希表。但是哈希表无法提供键值对的有序输出，红黑树因为是排序插入的，可以按照键的值的大小有序输出。红黑树性质：</p>
<p>性质1：每个节点要么是红色，要么是黑色。</p>
<p>性质2：根节点永远是黑色的。</p>
<p>性质3：所有的叶节点都是空节点（即 null），并且是黑色的。</p>
<p>性质4：每个红色节点的两个子节点都是黑色。（从每个叶子到根的路径上不会有两个连续的红色节点）</p>
<p>性质5：从任一节点到其子树中每个叶子节点的路径都包含相同数量的黑色节点。</p>
<h2 id="6-请你解释一下hashMap具体如何实现的？"><a href="#6-请你解释一下hashMap具体如何实现的？" class="headerlink" title="6.请你解释一下hashMap具体如何实现的？"></a>6.请你解释一下hashMap具体如何实现的？</h2><p>考点：集合</p>
<h4 id="参考回答：-7"><a href="#参考回答：-7" class="headerlink" title="参考回答："></a>参考回答：</h4><p>Hashmap基于数组实现的，通过对key的hashcode &amp; 数组的长度得到在数组中位置，如当前数组有元素，则数组当前元素next指向要插入的元素，这样来解决hash冲突的，形成了拉链式的结构。put时在多线程情况下，会形成环从而导致死循环。</p>
<p>数组长度一般是2n，从0开始编号，所以hashcode &amp; （2n-1），（2n-1）每一位都是1，这样会让散列均匀。</p>
<p>需要注意的是，HashMap在JDK1.8的版本中引入了红黑树结构做优化，当链表元素个数大于等于8时，链表转换成树结构；若桶中链表元素个数小于等于6时，树结构还原成链表。因为红黑树的平均查找长度是log(n)，长度为8的时候，平均查找长度为3，如果继续使用链表，平均查找长度为8/2=4，这才有转换为树的必要。</p>
<p>链表长度如果是小于等于6，6/2=3，虽然速度也很快的，但是转化为树结构和生成树的时间并不会太短。</p>
<p>还有选择6和8，中间有个差值7可以有效防止链表和树频繁转换。假设一下，如果设计成链表个数超过8则链表转换成树结构，链表个数小于8则树结构转换成链表，如果一个HashMap不停的插入、删除元素，链表个数在8左右徘徊，就会频繁的发生树转链表、链表转树，效率会很低。</p>
<h2 id="7-如果hashMap的key是一个自定义的类，怎么办？"><a href="#7-如果hashMap的key是一个自定义的类，怎么办？" class="headerlink" title="7.如果hashMap的key是一个自定义的类，怎么办？"></a>7.如果hashMap的key是一个自定义的类，怎么办？</h2><p>考点：集合</p>
<h4 id="参考回答：-8"><a href="#参考回答：-8" class="headerlink" title="参考回答："></a>参考回答：</h4><p>使用HashMap，如果key是自定义的类，就必须重写hashcode()和equals()。</p>
<h2 id="8-请问什么是IoC和DI？并且简要说明一下DI是如何实现的？"><a href="#8-请问什么是IoC和DI？并且简要说明一下DI是如何实现的？" class="headerlink" title="8.请问什么是IoC和DI？并且简要说明一下DI是如何实现的？"></a>8.请问什么是IoC和DI？并且简要说明一下DI是如何实现的？</h2><p>考察点：控制反转</p>
<h4 id="参考回答：-9"><a href="#参考回答：-9" class="headerlink" title="参考回答："></a>参考回答：</h4><p>IoC叫控制反转，是Inversion of Control的缩写，DI（Dependency Injection）叫依赖注入，是对IoC更简单的诠释。</p>
<p>控制反转是把传统上由程序代码直接操控的对象的调用权交给容器，通过容器来实现对象组件的装配和管理。</p>
<p>所谓的”控制反转”就是对组件对象控制权的转移，从程序代码本身转移到了外部容器，由容器来创建对象并管理对象之间的依赖关系。</p>
<p>IoC体现了好莱坞原则 - “Don’t call me, we will call you”。依赖注入的基本原则是应用组件不应该负责查找资源或者其他依赖的协作对象。</p>
<p>配置对象的工作应该由容器负责，查找资源的逻辑应该从应用组件的代码中抽取出来，交给容器来完成。</p>
<p>DI是对IoC更准确的描述，即组件之间的依赖关系由容器在运行期决定，形象的来说，即由容器动态的将某种依赖关系注入到组件之中。</p>
<p>一个类A需要用到接口B中的方法，那么就需要为类A和接口B建立关联或依赖关系，最原始的方法是在类A中创建一个接口B的实现类C的实例，但这种方法需要开发人员自行维护二者的依赖关系，也就是说当依赖关系发生变动的时候需要修改代码并重新构建整个系统。</p>
<p>如果通过一个容器来管理这些对象以及对象的依赖关系，则只需要在类A中定义好用于关联接口B的方法（构造器或setter方法），将类A和接口B的实现类C放入容器中，通过对容器的配置来实现二者的关联。<br>依赖注入可以通过setter方法注入（设值注入）、构造器注入和接口注入三种方式来实现，Spring支持setter注入和构造器注入，通常使用构造器注入来注入必须的依赖关系，对于可选的依赖关系，则setter注入是更好的选择，setter注入需要类提供无参构造器或者无参的静态工厂方法来创建对象。</p>
<blockquote>
<p>赵文卓 4</p>
<p>任瑞鹏 4</p>
<p>马寅琪 2</p>
<p>张一博 4</p>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/10/07/Java%E9%9D%A2%E8%AF%95%E9%A2%98/" data-id="ckfyur5300000ucuf4wnhczma" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2020/10/07/%E9%9D%A2%E8%AF%95/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          (no title)
        
      </div>
    </a>
  
  
    <a href="/2020/10/07/%E5%A6%82%E4%BD%95%E9%85%8D%E7%BD%AEnode.js/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title"></div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/10/">October 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/10/07/%E9%9D%A2%E8%AF%95/">(no title)</a>
          </li>
        
          <li>
            <a href="/2020/10/07/Java%E9%9D%A2%E8%AF%95%E9%A2%98/">(no title)</a>
          </li>
        
          <li>
            <a href="/2020/10/07/%E5%A6%82%E4%BD%95%E9%85%8D%E7%BD%AEnode.js/">(no title)</a>
          </li>
        
          <li>
            <a href="/2020/10/07/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0/">我的第一篇博客文章</a>
          </li>
        
          <li>
            <a href="/2020/10/07/hello-world/">Hello World</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>